// rest 문법 // 1. 매개변수에는 하나의 `rest`만 존재할 수 있습니다. // 2.
`rest`는 반드시 함수 정의의 마지막 매개변수여야 합니다. function 함수2(a, b,
...c) { console.log(c); return Math.max(...c); } 함수2("hello", "world", 10, 20,
30, 40); function 함수2([a, b], ...c) { console.log(a); console.log(b);
console.log(c); } 함수2([1, 2], 10, 20, 30, 40); //매개변수의 초기화 // 초기화는
할 수 있지만 순서를 바꿀 수 없습니다. function 함수3(a = 10, b = 20, c = 30) {
return a + b + c; } // 3020이 되어야 하는거 아니에요? console.log(함수3((c =
1000), (a = 2000))); // 3030 //자바스크립트 scope //스코프 체이닝. 변수가 없으면
상위 스코프에서 찾는 것이 반복적으로 일어남 // 함수 안에서도 밖의 변수를
참조하고 수정 할 있습니다. // python과 다름. python은 참조 가능, 수정할 수 없음.
let z = 100; function sum(x) { // x는 매개변수(parameter)이면서 지역변수(local
val) let y = 50; // y는 지역변수 z = z + y; return x + y; }
console.log(sum(10)); // 10은 전달인자(argument) // console.log(x); // 변수없음
// console.log(y); // 변수없음 console.log(z); // 키워드로 인해 전역, 지역이
갈리는 것은 아닌지, let, var, const 모두 테스트 해보세요. // 블록 레벨 스코프 if
(true) { // for문이어도 마찬가지입니다. let x = 10; const y = 10; }
console.log(x, y); // 밖에 선언된 x는 함수 내부에서도 접근 가능합니다. let x =
100; function xplus() { x = x + 10; console.log(x); } xplus(); console.log(x);
// 함수 안에 함수 function a() { console.log("a 실행"); function b() {
console.log("b 실행"); } b(); } a(); // b() // Error //블록레벨 스코프 연습 {
let a = 10; const b = 10; console.log(a); console.log(b); { let a = 15; const b
= 15; console.log(a); console.log(b); { let a = 20; const b = 20;
console.log(a); console.log(b); } } } // 콜백함수 // 함수의 매개별수로 전달되어
실행되는 함수 // 함수에 아규먼트로 전달 function sum(x, y) { return x + y; }
function custom(x, y, func) { return func(x, y); } custom(10, 20, sum); //
콜백함수 예시 // let arr = [1,2,3] // arr.sort(콜백함수) // arr.filter(콜백함수)
// arr.map(콜백함수) function f(x) { return x ** 2; } [1, 2, 3].map((x) => x **
2); [1, 2, 3].map(f); //함수의 호이스팅(Hoisting) // 함수가 호출 부분보다 밑에
있어도 에러를 뱉지 않고, 함수 선언을 최상단으로 끌어 올려지는 현상 // 변수와
함수의 호이스팅은 내용이 많습니다. ` hello() # NameError: name 'hello' is not
defined def hello(): print('hello world') `; hello(); function hello() {
console.log("hello world"); }
<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title></title>
  </head>
  <body>
    <script>
      // 참고자료 : https://hanamon.kr/javascript-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85%EC%9D%B4%EB%9E%80-hoisting/
      // JS의 모든 선언은 호이스팅(선언이 먼저 메모리에 저장)이 일어납니다.
      // 그러나 let, const, class 이용한 선언문은 호이스팅이 되었지만 안된 것처럼 동작
      // 이러한 현상은 일시적 사각지대(Temporal Dead Zone)에 빠지기 때문
      // 중요한 포인트는 그렇다하여 호이스팅이 안된 것은 아니라는 것!
      // 오류가 나는 이유는 var 키워드는 선언과 함께 undefined로 초기화
      // let과 const는 초기화 되지 않는 상태로 선언만 메모리 저장
      console.log(add1(10, 20)); // 30
      console.log(add2(10, 20)); // 30
      console.log(mul1); // undefined > 실행은 안됬지만 변수가 생기기는 했기 때문에 undefined
      // console.log(mul1(10, 20)); // not a function
      // console.log(mul2); // Cannot access 'mul2' before initialization
      // console.log(mul2(10, 20)); // 위와 같은 애러
      // console.log(mul3) // mul3 is not defined, 호이스팅이 안되었기 때문

      function add1(x, y) {
        return x + y;
      }

      function add2(x, y) {
        return x + y;
      }

      var mul1 = function (a, b) {
        return a * b;
      };

      let mul2 = function (a, b) {
        return a * b;
      };
    </script>
  </body>
</html>
