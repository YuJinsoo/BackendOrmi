# 리눅스

- 리눅스(Linux)는 운영 체제의 하나로, 유닉스 시스템을 기반으로 한 오픈 소스 소프트웨어입니다. 
- 리누스 토르발스(Linus Torvalds)가 1991년에 개발하였습니다. git 개발한 사람...

- 오픈 소스 라이선스인 GPL(General Public License)로 배포되어 있습니다. 
- 전 세계의 개발자들이 리눅스에 기여하고, 수정하고, 그 변형을 배포하며, 이것이 바로 리눅스의 큰 특징이며 강점입니다. 

- 리눅스는 서버, 슈퍼 컴퓨터, 개인 컴퓨터 뿐만 아니라 스마트폰(안드로이드 운영 체제), 태블릿, 임베디드 시스템 등 다양한 시스템에서 운영 체제로 사용되고 있습니다. 
- 가상화, 클라우드 컴퓨팅, 컨테이너 기술 등과 같은 현대적인 컴퓨팅 환경에도 뛰어난 호환성을 보이며, 이런 분야에서도 많이 활용되고 있습니다.

- 리눅스의 중요한 구성 요소 중 하나는 리눅스 커널입니다. 
- 커널은 하드웨어와 소프트웨어 사이에서 중재자 역할을 하며, 시스템 리소스를 효율적으로 관리합니다. 

> 배포판으로는 Ubuntu, Fedora, Debian, CentOS 등이 있으며, 각각 다른 목적과 사용자를 위해 설계되었습니다.

- 리눅스는 그 자유롭고 개방적인 특성, 그리고 확장성과 유연성 때문에 전 세계에서 널리 사용되고 있으며, IT 분야에서 빼놓을 수 없는 중요한 기술입니다.

## 커널과 쉘

### 커널
- 커널이란 OS 핵심이 되는 부분, 즉 OS 자체를 말합니다.
- 하드웨어와 직접적으로 상호 작용합니다. 
- 커널은 시스템의 모든 리소스를 관리하고 이를 애플리케이션에 제공합니다.
- 리소스 관리는 프로세스 관리, 메모리 관리, 디스크 관리 등을 포함합니다. 
- 커널은 또한 하드웨어에서 발생하는 인터럽트를 처리하며, 사용자와 하드웨어 사이에서 중재자 역할을 합니다.

### 쉘

- 사용자는 쉘을 통해 커널에 명령할 수 있습니다.
- 쉘은 사용자와 운영 체제 사이의 인터페이스로 작동합니다. 

- bash 쉘, z 쉘?


## 파일과 디렉토리

### 파일

- 일바적으로 텍스트 파일과 바이너리 파일로 분류됩니다.
  - 텍스트 파일 : 텍스트(문자)가 입력된 파일이다. 텍스트 에디터 등으로 열람이나 편집이 가능합니다.
  - 바이너리 파일 : 프로그램이나 기타 데이터를 포함한 파일로, 텍스트 에디터로는 열람이나 편집은 할 수 없습니다.

- Linux에서 취급하는 파일은 실행할 수 있는 파일과 실행할 수 없는 파일로 나눌 수 있다.
- 실행할 수 있는 파일
    - 프로그래밍 언어 : 프로그래밍 언어에 따라 특정한 처리를 위해 만들어진 바이너리 파일
    - 쉘 스크립트 : 셀스크립트라는 명령을 기술한 텍스트 파일
- 실행할 수 없는 파일
    - 데이터 파일이나 설정 파일 등 왼쪽에 열거한 종류 이외의 파일

### 디렉토리

Linux에서는 파일을 저장하는 장소가 디렉터리라는 단위로 분류되어 있다. 
디렉터리는 트리구조(계층구조)로 되어있다.

**Linux 디렉터리 구조**는 계층적으로 구성되어 있으며, 이를 파일시스템 트리라고도 부릅니다. 
모든 것이 '/'라는 루트 디렉터리에서 시작합니다.

- **`/`**: 루트 디렉터리로, 모든 디렉터리의 시작점입니다.
- **`/bin`**: 기본적인 실행 가능한 프로그램(binary)들이 저장된 디렉터리입니다.
- **`/etc`**: 시스템 설정 파일들이 저장된 디렉터리입니다.
- **`/home`**: 각 사용자의 홈 디렉터리를 포함하고 있습니다. 예를 들어 사용자 이름이 'user'라면 해당 사용자의 홈 디렉터리는 '/home/user'가 됩니다.
- **`/var`**: 시스템 운영 중에 생성되는 가변 데이터를 저장하는 디렉터리입니다.
- **`/usr`**: 사용자 관련 애플리케이션 및 파일을 저장하는 디렉터리입니다.
- **`/lib`**: 시스템 라이브러리 파일을 저장하는 디렉터리입니다.
- **`/dev`**: 디바이스 파일을 포함하는 디렉터리입니다. Linux에서는 하드웨어를 파일로 간주하기 때문에 이 디렉터리에는 모든 하드웨어 장치 파일이 포함됩니다.
- **`/tmp`**: 일시적인 파일을 저장하는 디렉터리입니다.



## 경로와 확장자

### 경로

경로는 파일이나 디렉토리의 위치를 나타냅니다. 
Linux에서 경로는 두 가지 유형이 있습니다: 절대 경로와 상대 경로입니다.

- 절대경로
  절대 경로는 루트 디렉토리인 '/'에서 시작하여 특정 파일이나 디렉토리에 도달하는 완전한 경로입니다. 
  예를 들어, "/home/user/documents/example.txt"는 절대 경로입니다. 
  이 경로는 어느 디렉토리에서든지 동일한 위치를 가리킵니다.
  
- 상대경로
  상대 경로는 현재 디렉토리에 기반하여 특정 파일이나 디렉토리의 위치를 나타냅니다. 
  예를 들어, 현재 디렉토리가 "/home/user"이고, "documents/example.txt"라는 파일에 접근하려면 상대 경로를 사용할 수 있습니다. 
  이 경로는 현재 위치에 따라 다른 위치를 가리키게 됩니다
  다음은 상대 경로의 몇 가지 예시입니다:
  1. 현재 디렉토리가 **`/home/user`**이고 **`documents`**라는 디렉터리에 있는 **`file.txt`**라는 파일에 접근하려면, 상대 경로는 **`documents/file.txt`**가 됩니다.
  2. 현재 디렉토리가 **`/home/user/documents`**이고 **`images`** 디렉터리에 있는 **`picture.jpg`**라는 파일에 접근하려면, 상대 경로는 **`images/picture.jpg`**가 됩니다.
  
  또한 **`.`**과 **`..`**을 이용해 상대 경로를 나타낼 수도 있습니다.
  - **`.`**은 현재 디렉터리를 의미합니다.
  - **`..`**은 상위 디렉터리를 의미합니다.


- 홈디렉토리  ~ 
  - 리눅스에서 홈 디렉토리는 각 사용자가 로그인했을 때 기본적으로 위치하게 되는 디렉토리를 말합니다.
  
  - 리눅스 쉘에서는 홈 디렉토리를 '~' (틸드) 기호로도 표현할 수 있습니다. 따라서 /home/john 디렉토리는 '~' 또는 '~/`로 참조할 수 있습니다.
  

### 확장자
- 닷파일 (.file)
  - 리눅스에서 "닷 파일"(.file)이란 이름이 . (점)으로 시작하는 파일을 말합니다. 
  이 파일들은 일반적으로 사용자의 홈 디렉토리에 위치해 있으며, 다양한 애플리케이션과 프로그램의 설정 정보를 저장하는 데 사용됩니다.
  이런 파일들은 대개 숨겨진 파일로 간주되어 파일 브라우저나 'ls' 명령어 등을 통해 일반적으로는 보이지 않습니다. 
  하지만 'ls -a' 명령어를 사용하면 이런 숨겨진 파일들도 볼 수 있습니다.

  - 예를 들어, '.bashrc', '.profile', '.gitconfig' 등이 이러한 닷 파일에 속합니다. 
  이들 파일들은 각각 Bash 쉘, 사용자 프로필, Git 설정 등에 대한 사용자 정의 설정을 포함합니다.

    - .bashrc : 이 파일은 bash 쉘에 로그인할 때마다 실행되는 스크립트입니다. 
    여기에는 환경 변수 설정, 별명(alias), 함수 등 bash 쉘의 동작을 정의하는 설정이 포함됩니다.
    - .profile : 이 파일은 사용자가 로그인할 때 시스템이 읽는 파일입니다. 
    .profile 파일은 로그인 쉘의 초기화 스크립트로, 여기에는 환경 변수, 사용자 경로, 실행할 스크립트 등을 정의할 수 있습니다.
    - .gitconfig : 이 파일은 Git의 전역 설정을 포함하고 있습니다. 
    사용자 이름, 이메일 주소, 별명(alias), 색상 등 Git 동작에 영향을 주는 설정을 여기에서 관리할 수 있습니다.

  - 따라서 닷 파일은 리눅스에서 중요한 역할을 하는 설정 파일이며, 사용자는 이를 통해 시스템의 다양한 동작을 사용자 정의할 수 있습니다. 
  그러나 이런 파일들은 중요한 설정을 담고 있으므로, 편집이나 변경을 할 때는 주의가 필요합니다.
  
    - 맨 앞에 .을 붙인 파일들은 `ls`명령어로 조회되지 않습니다. `ls -a`로 해야 보입니다.


> 리눅스에서 설치시 참고!
> 리눅스에 설치를 원하는 프로그램을 찾을 떄 아래 키워드로 찾으면 금방 찾을 수 있음.
> install xxx on OS
> ex) install nginx on ubuntu 22.04
> 디지털오션(digitalocean) 에서 설치 방법이 잘 찾아집니다.


## 기본적인 제어. 리눅스 명령어

- https://paullabworkspace.notion.site/1db618eec9124578811adb7443cc0607

- cd
- cp
- mv

- ls -l 리스트 형태로 출력
  - 권한 소유자 소유그룹 용량 생성일자/시간 이름
  - 권한에 맨앞자리가 d면 폴더(directory) -는 파일
  - ls -al 약자 ll 도 씀

- mkdir
- rmdir
- rm
- cat
- sort
- grep

- `|` 양쪽 명령어를 연속으로 진행할 때

- `>` 는 파일을 새로 열고 덮어씀
- `>>` 는 뒤에 내용을 추가해줌

> 참고!
> 로그파일은 /var/log 경로에 모여있음
> 설정파일은 /etc 경로에 모여있음


- 현재 실행되는 프로세스 : ps aux
  - python 실행되나? : ps aux | grep python

- find
  - find . -name "hello*"

- touch
  - 빈파일도 만들지만, 있는 파일일 경우 수정시간을 최신화해줌

- which
  - Unix 및 Unix 계열 운영 체제(예: Linux)에서 사용되는 명령어로, 특정한 실행 가능 파일의 경로를 찾아주는 역할을 합니다. 특히 시스템에 설치된 소프트웨어의 위치를 찾을 때 유용합니다.
  - `which python3`

- whereis
  - Linux에서 특정 바이너리(executable), 소스, 또는 매뉴얼 페이지 파일의 위치를 찾을 때 사용되는 명령어입니다. 이 명령어는 표준 Linux 파일 시스템에 위치한 이들 파일을 빠르게 찾을 수 있게 도와줍니다.
  - `whereis python3`
  - `-b` : 바이너리 파일만 찾습니다.
  - `-m` : 매뉴얼 페이지만 찾습니다.
  - `-s` : 소스 파일만 찾습니다.
  - `-u` : 언급한 위치에서 파일을 찾지 못했을 경우 사용합니다.

- 와일드카드
  - `*` 모든
  - `?` 글자한개 모두

---

## vi 에디터

- 백엔드 개발자가 서버에 접속해서 하는 일
  - 개발서버 환경설정
  - 운영서버 환경설정
  - 배포설정
  - 운영상의 조치 (로그파일 조회, 서버 파일 수정, 환경설정파일 수정 등등)

- 리눅스 CLI (Command Line Interface) 환경에서 텍스트 에디터는 매우 중요한 도구입니다. 이것이 필요한 주요 이유는 다음과 같습니다:

1. **파일 편집**: 텍스트 파일, 스크립트, 소스 코드, 설정 파일 등 다양한 파일들을 만들고 편집하는데 사용됩니다.
2. **스크립트 작성**: Shell 스크립트 또는 다른 프로그래밍 언어로 스크립트를 작성하고 편집할 수 있습니다.
3. **시스템 설정 변경**: 시스템 설정 파일을 편집하여 서버 또는 시스템 설정을 조정할 수 있습니다.
4. **프로그래밍**: 코드를 작성하고 편집하는 데 필요합니다. 텍스트 에디터는 프로그래밍에 있어 기본적인 도구입니다.


### 주요 텍스트 에디터 종류

1. **Vim**: Vim은 확장 가능하고 매우 강력한 텍스트 에디터로, 키보드 명령을 통해 효율적인 텍스트 편집을 가능하게 합니다. Vim은 또한 많은 플러그인을 지원하여 사용자가 원하는 기능을 추가할 수 있습니다.
2. **Emacs**: Emacs는 또 다른 강력한 텍스트 에디터로, 그것의 기능은 거의 무한합니다. Emacs는 거의 모든 프로그래밍 언어를 지원하며, 이메일 클라이언트, 뉴스 리더, 텍스트 브라우저 등과 같은 여러 유용한 도구를 포함하고 있습니다.
3. **Nano**: Nano는 Vim이나 Emacs와 같은 강력한 기능은 가지고 있지 않지만, 초보자가 사용하기에는 더 쉬운 텍스트 에디터입니다. Nano의 모든 주요 명령은 화면 하단에 표시되므로 쉽게 접근할 수 있습니다.

- 이 세 가지 텍스트 에디터는 모두 터미널에서 실행됩니다. 이들은 강력하고 유연하며, 사용자가 리눅스 시스템을 제어하고 코드를 작성하는 데 필요한 모든 기능을 제공합니다. 
- 특히 Vim과 Emacs는 그들의 많은 확장 기능과 사용자 정의 가능성으로 인해 많은 개발자들 사이에서 인기가 있습니다. 
- 그러나 그들의 학습 곡선은 다소 가파르므로, 초보자는 일반적으로 Nano와 같은 더 간단한 텍스트 에디터로 시작합니다.


230712
## 실행과 종료

- `vi`는 UNIX나 Linux 운영 체제에서 사용하는 텍스트 편집기입니다. 

- `vim` 편집기를 좀더 많이 사용합니다.
- 터미널에서 `vim`를 입력한 후, 뒤에 파일 이름을 추가합니다. 
```bash
vim # vim 에디터만 open
vim test.txt # vim 에디터로 test.txt open, 파일이 없으면 생성함
```

vi를 종료하려면:

1. `esc` 키를 눌러 편집 모드에서 명령 모드로 전환합니다.
2. 다음으로, 종료하거나 저장하고 종료하려는 명령을 입력합니다.
    - `:q`를 입력하고 엔터를 누르면 vi를 종료합니다. 변경 사항이 저장되지 않았다면, vi는 파일을 저장하도록 알립니다.
    - `:q!`를 입력하고 엔터를 누르면 변경 사항을 저장하지 않고 vi를 종료합니다.
    - `:w` 를 입력하고 엔터를 누르면 저장합니다.
    - `:wq`를 입력하고 엔터를 누르면 변경 사항을 저장하고 vi를 종료합니다.

이 명령들은 vi뿐 아니라 vim(Improved vi)에서도 동일하게 적용됩니다.


## vi 모드 변경

vi 에디터는 기본적으로 세 가지 모드를 가지고 있습니다.

1. **명령 모드(Command Mode)**: 이 모드에서는 텍스트 편집이 아닌 커서 이동, 복사 및 붙여넣기, 삭제 등의 명령을 수행할 수 있습니다. vi 에디터를 처음 시작하면 기본적으로 이 모드로 시작합니다.
2. **입력 모드(Insert Mode)**: 이 모드에서는 실제로 텍스트를 입력하거나 수정할 수 있습니다. 명령 모드에서 `i`, `a`, `o` 등의 키를 눌러 입력 모드로 전환할 수 있습니다.
3. **라인 명령 모드(Line Command Mode)**: 이 모드에서는 파일 저장, vi 종료, 검색 및 치환 등의 명령을 수행할 수 있습니다. 명령 모드에서 `:` 키를 눌러 라인 명령 모드로 전환할 수 있습니다.

- 명령 모드에서 입력 모드로 전환: `i`, `a`, `o` 등의 키를 사용
- 입력 모드에서 명령 모드로 전환: `ESC` 키를 사용

- 명령 모드에서 라인 명령 모드로 전환: `:` 키를 사용
- 라인 명령 모드에서 명령 모드로 전환: `Enter` 키를 사용한 후 명령 실행



## vi 기본 조작

command모드에서
- 입력모드 : i
- 줄추가 : o
- 한글자 삭세 : x
- 한줄 삭제 : d d
- 여러줄 삭세 : d 삭제줄 수 d
- 줄복사 : yy
- 붙여넣기 : p

- 맨아래로 이동 : G (shift g)
- 맨위로 이동 : gg

- 이동
  - 방향키,
  - h left
  - j down
  - k up
  - l right

- 단어검색 : `:/검색할 단어`
- 검색하고 이동 : n 다음단어로 이동


> tip!
> `/etc/logrotate.d` 이 경로에 로그 남기는 규칙? 을 설정할 수 있습니다.
> 이런 파일들을 수정할 때 vim같은걸 사용하는 겁니당.
> 여기 경로에 apt 파일을 수정.
> 근데 그냥 vim apt로 열면 안됨 읽기전용이라
> sudo vim apt 로 해야 수정할 수 있습니다.

> 리눅스 : df -h
> 무슨명령어야.?


## 추가명령어

- wc : 글자수, 줄수 세기
  - find . -name "*.txt" | wc -l
  - find . -name "*.txt" | wc -c

- uniq는 중복제거
  - cat file.txt | sort | uniq


## 링크 작성하기

- 쉽게 설명하면 바로가기 아이콘을 만드는 것이라고 생각하면 됩니다.
- 리눅스에서는 하드 링크와 심볼릭 링크가 있습니다.

1. 하드 링크: 원본 파일과 동일한 노드를 가리키는 파일입니다. 파일 시스템 내에서 데이터 블록을 공유합니다. 하드 링크는 원본 파일이 삭제되더라도 데이터에 계속 액세스할 수 있습니다.
2. 심볼릭 링크(또는 소프트 링크): 원본 파일을 가리키는 별도의 파일입니다. 파일에 대한 "바로 가기"와 같습니다. 원본 파일이 삭제되면 심볼릭 링크는 더 이상 유효하지 않습니다.


### 명령어 실행 파일을 찾는 순서

- /bin 디렉토리에 대부분의 명령어가 들어와있습니다.

1. 명령어 입력 시 현재 경로에 있는지 찾음
2. 없으면 환경병수 path에 가서 찾음

- 보통 환경변수 pat에 등록된 폴더인 /bin에 있습니다.
- `echo $PATH` 로 PATH로 지정된 경로를 확인할 수 있습니다.
- 해당 경로에 들어가서 ls -al로 확인해보면
  - 실제 파일이 있으면 이름만 있음
  - 링크로 걸려있으면 vi -> /etc/alternatives/vi 이런식으로 표시됨


### 링크생성

- `ln`명령어로 링크를 생성할 수 있습니다.
- 아무런 옵션 없이 생성하면 하드링크가 생성됩니다.
- 아래처럼 `-s` 옵션으로 심볼릭 링크 생성이 가능합니다.

```bash
# 소프트링트생성
# 링크를 만들고 싶은 경로로 이동한 다음
ln -s 원본경로 링크파일
ln -s /home/ubuntu/source/file.txt file_link.txt
# 생성된 파일 권한은 rwxrwxrwx
```

## 메모리와 디스크 명령

- 서버가 멈추지 않고잘 돌아가는지 모니터링하는것도 중요합니다.

### 메모리 사용량 

리눅스에서 `free` 명령어는 시스템의 전체 메모리 사용 상황을 확인하는 데 사용됩니다. 
이 명령어는 여러 가지 옵션과 함께 사용되며, 이는 여러 가지 형태의 출력을 제공하도록 구성할 수 있습니다.

다음은 `free` 명령어의 출력을 이해하는 데 도움이 되는 주요 필드들입니다:

- **total**: 전체 메모리 양입니다.
- **used**: 사용중인 메모리 양입니다.
- **free**: 사용되지 않은 메모리 양입니다.
- **shared**: 공유 메모리 양입니다.
- **buff/cache**: 버퍼 및 캐시로 사용되는 메모리 양입니다.
- **available**: 프로그램에 사용 가능한 메모리 양입니다.


### 디스크 사용량
- 디스크 사용량도 매우 중요합니다.

- `df`는 "disk filesystem"의 약자로, 리눅스에서 파일 시스템의 디스크 사용량을 확인하는 명령어입니다. 
- 파일 시스템의 이름, 전체 공간, 사용된 공간, 사용 가능한 공간, 사용량의 퍼센트, 그리고 해당 파일 시스템이 마운트된 위치를 보여줍니다.

명령어는 다음과 같은 옵션을 함께 사용할 수 있습니다:

- `-h` : 용량을 가독성이 좋은 형태 (예: K, M, G)로 표시합니다.
- `-a` : 모든 파일 시스템을 보여줍니다.
- `-T` : 각 파일 시스템의 유형을 표시합니다.
- `-i` : inode 정보를 표시합니다.

- `df -h`

### 파일 및 디렉터리의 크기

- `du` 명령어는 "disk usage"의 줄임말로, 리눅스 및 유닉스 시스템에서 파일 또는 디렉토리가 차지하는 디스크 공간을 확인하는 데 사용합니다.

```bash
du [options] [directories and/or files]
```

- `-a` : 모든 파일과 디렉토리의 디스크 사용량을 출력합니다.
- `-h` : "Human-readable" 옵션으로, 크기를 쉽게 이해할 수 있는 형태로 출력합니다. 예를 들어, KB, MB, GB 등으로 표시합니다.
- `-s` : 디렉토리의 총 합계만을 출력합니다 ("summary").
- `-S` : 하위 디렉토리는 제외하고 현재 디렉토리의 디스크 사용량만을 출력합니다.
- `-c` : 모든 파일과 디렉토리의 사용량을 출력하고 그 합계도 출력합니다.



### 시각화된 메모리 사용량 top

- top 명령어가 많이 사용됩니다.
- cpu , memory 사용율 보여줌
- htop은 더 시각화해서 보여줌

- htop은 설치되지 않은 경우가 있기 때문에 설치해줘야 합니다.

- gtop이란 것도 있습니다.
sudo apt update
sudo apt install gtop
https://github.com/aksakalli/gtop



### 사용자관련 명령. 비밀번호

- `sudo su -` : 관리자 계정으로 로그인합니다.

- 암호바꾸기
passwd
root password : 1q2w3e4r
exit 하면 root 로그아웃

- ubuntu계정 패스워드 바꾸기..
```bash
sudo su - # 관리자 계정 진입 후
passwd ubuntu # 비밀번호 바꿀 계정

#비밀번호 입력

exit # 관리자 계정 로그아웃
```


## 권한

- 파일이나 디렉토리의 권한은 파일이나 디렉토리에 대한 사용자나 그룹의 액세스 권한을 제어합니다. 권한은 일반적으로 세 가지 속성을 가지며, 이는 읽기, 쓰기, 실행입니다.

1. 읽기 (Read, r): 파일을 읽을 수 있는 권한을 부여합니다. 디렉토리의 경우, 디렉토리 내부의 파일 목록을 읽을 수 있는 권한을 부여합니다.
2. 쓰기 (Write, w): 파일에 쓸 수 있는 권한을 부여합니다. 디렉토리의 경우, 디렉토리 내부에 파일을 생성하거나 삭제할 수 있는 권한을 부여합니다.
3. 실행 (Execute, x): 파일을 실행할 수 있는 권한을 부여합니다. 스크립트나 프로그램에 주로 사용되며, 디렉토리의 경우 해당 디렉토리로 이동할 수 있는 권한을 부여합니다.

그리고 리눅스의 권한 관리는 세 가지 사용자 범주로 구분됩니다.
1. 소유자 (Owner): 파일 또는 디렉토리의 소유자는 파일을 생성한 사용자입니다. 소유자는 파일에 대한 모든 권한을 가질 수 있습니다.
2. 그룹 (Group): 파일 또는 디렉토리는 하나의 그룹을 가질 수 있으며, 이 그룹에 속한 사용자들은 그룹 권한에 따라 파일에 접근할 수 있습니다.
3. 기타 사용자 (Others): 소유자나 그룹에 속하지 않은 다른 모든 사용자들을 가리킵니다. 이들 사용자들은 '기타 사용자'에 부여된 권한에 따라 파일에 접근할 수 있습니다.


### 권한 확인

- 파일 권한은 `ls -l`로 확인할수 있습니다.

- 출력된 결과는 'r', 'w', 'x' 또는 '-'로 표시됩니다. 이들 문자는 각각 읽기, 쓰기, 실행 권한이 있음 또는 없음('-')을 나타냅니다. 
- 권한은 '소유자', '그룹', '기타 사용자' 순서로 표시되며, 각 범주는 세 문자('rwx')로 표현됩니다.

첫 번쩨 문자
- 일반 파일
d 디렉토리
l 심볼릭 링크
b 블록 스페셜 파일
c 문자 스페셜 파일
p 파이프
s 소켓


### 권한의 설정

- `chmod`

- 심볼릭모드
```bash
chmod u-x hello.sh
# hello.sh파일의 유저의 실행권한을 제거하겠다.

chmod u-w *.txt
# 모든txt파일의 쓰기권한 삭제

```
- 유저는 u 그룹은 g 아무나는 o
- 추가하는건 + 제거하는건 -


- 숫자모드
  - u,g,o 에 대한 권한을 숫자로 매핑해놓았음.
  - 0부터7까지 권한의 종류가 다릅니다.

```bash
chmod 777 1.txt
#1.txt의 u, g, o 권한을 rwx 모두 추가

chmod 400 1.txt
#소유자만 읽기권한 주고 나머지 다 뺏음
```

- 0  권한 없음 
- 1  실행 
- 2  쓰기 
- 3  쓰기, 실행 
- 4  읽기 
- 5  읽기, 실행 
- 6  읽기, 쓰기 
- 7  읽기, 쓰기, 실행 



- chown
소유자를 변경할 수 잇는 명령어가
```bash
sudo chown root:root 1.txt
```
파일 소유자가 아니면 권한이 없기 때문에 권한설정을 할수없다. (관리자제외)


## 쉘스크립트

- 리눅스의 쉘 스크립트는 리눅스 운영 체제에서 자동화 작업을 수행하기 위한 스크립트 언어입니다. 
- 이것은 사용자가 반복적인 작업을 수행하는 데 필요한 시간을 줄이기 위해 일련의 명령을 실행하는 데 사용됩니다. 
- 쉘 스크립트는 일반적으로 쉘 환경에서 실행되며, Bash(Bourne Again SHell) 등의 다양한 쉘에서 사용할 수 있습니다.

- 쉘 스크립트는 텍스트 파일로 작성되며, 이 파일에는 실행할 쉘 명령이 포함됩니다. 
이 스크립트는 텍스트 에디터(예: vi, nano 등)로 작성하고, 이후에는 실행 권한을 부여하여 실행 파일로 만들 수 있습니다. 
- 이 스크립트는 실행 권한이 있는 한 어디에서나 실행될 수 있습니다.

- 확장자 `.sh`

- 처음 파일 생성하면 실행권한 x가 없을 것이기 때문에, chmod로 실행 권한을 설정해주어야 합니다.
chmod u+x 파일명


- 맨 위에bash 쉘의 경로를 입력해줌
```shell
#!/bin/bash
echo "start"
echo "end"
```

- 스크립트 언어로 파이썬을 지정해 줄 수있습니다.
```shell
#!/usr/bin/python3
print("hello world python")

```

- 조건문이나 반복문을 사용할 수 있습니다.

- 중간에 에러가 발생해도 끝까지 실행합니다. 이러한 특성을 고려해서 굉장히 방어적으로 자동화코드를 작성해야 합니다.


## 멀티 태스크와 프로세스 제어

- `ps` 명령어. Process Status.
- 현재 시스템에서 실행 중인 프로세스의 정보를 출력해줍니다. 프로세스 ID, 사용자 ID, CPU 사용 시간, 프로세스가 시작된 시간, 프로세스명 등 다양한 정보를 볼 수 있습니다.

- 많이 쓰이는 옵션 : `-ef`

```bash
ps -ef | grep nginx
ps -ef | grep django
ps -ef | grep python

```

- 프로세스 종료 : `kill 프로세스넘버`

```bash
kill 1234
#kill 명령어는 기본적으로 SIGTERM (시그널 15)을 전송합니다. SIGTERM은 프로세스에게 종료하도록 요청하는 시그널이며, 프로세스는 이를 무시하거나 처리할 수 있습니다.

kill -9 1234
#만약 프로세스가 SIGTERM을 무시하거나 종료하지 않는다면, 더 강력한 SIGKILL (시그널 9)을 전송할 수 있습니다. 이 시그널은 프로세스가 무시하거나 처리할 수 없으며, 즉시 프로세스를 종료시킵니다. SIGKILL을 전송하려면 다음과 같이 -9 옵션을 사용합니다:

```


## 시스템 관리자

### 사용자 전환하기

- `su` 명령어 사용
- Linux와 같은 Unix 기반 시스템에서 사용되는 명령어입니다. 
- "substitute user" 또는 "switch user"의 약자로, 현재 로그인한 사용자의 ID를 다른 사용자의 ID로 변경하는 역할을 합니다. 


```Bash
su [options] [username]
```

```Bash
su -        # root 사용자로 전환합니다.
su - john   # 'john'이라는 사용자로 전환합니다.
su john   # 'john'이라는 사용자로 전환합니다.
su -c whoami john # 'john'이라는 사용자로 전환하여 'whoami' 명령어를 실행하고 다시 원래 사용자로 돌아갑니다.
```

- sudo 명령어
sudo 명령어는 아무나 칠수 없습니다.


## 시스템 관리명령

### systemctl

`systemctl`은 systemd의 주요 컨트롤 도구로, 서비스를 시작하고, 중지하고, 재시작하거나 그 상태를 확인하는 등의 작업을 수행할 수 있습니다. 사용법은 대개 `systemctl [명령] [서비스 이름]` 형태입니다.

다음은 몇 가지 예시입니다:

1. **서비스 시작**:
    
    ```bash
    systemctl start [서비스이름]
    ```
    
    예를 들어, SSH 서비스를 시작하려면 다음과 같이 입력합니다:
    
    ```bash
    systemctl start sshd.service
    ```
    
2. **서비스 중지**:
    
    ```bash
    systemctl stop [서비스이름]
    ```
    
    예를 들어, Apache 웹 서버를 중지하려면 다음과 같이 입력합니다:
    
    ```bash
    systemctl stop apache2.service
    ```
    
3. **서비스 재시작**:

예를 들어, MySQL 서비스를 재시작하려면 다음과 같이 입력합니다:

```bash
systemctl restart mysql.service
```

4. **서비스 상태 확인**:
    
    ```bash
    systemctl status [서비스이름]
    ```
    
    예를 들어, Postfix 메일 서버의 상태를 확인하려면 다음과 같이 입력합니다:



- 서버 실행시 자동실행이 안되는 경우가 있음
nginx같은웹서버, db같은거는 그래야함

이런 것들은 enable로 지정할 수 있음

```Bash
sudo systemctl enable nginx
```

## 네트워크 명령

## 사용자 생성과 삭제

### 사용자 생성

- adduser 사용자명
- 근데 관리자만 생성할 수 있기 때문에 sudo adduser 사용자명

다음은 `adduser`의 주요 옵션들입니다:
- `--home` : 새 사용자의 홈 디렉토리를 설정합니다.
- `--shell` : 새 사용자의 로그인 셸을 설정합니다.
- `--no-create-home` : 홈 디렉토리를 만들지 않습니다.
- `--uid` : 새 사용자의 유니크한 사용자 ID를 설정합니다.
- `--group` : 새 사용자의 초기 그룹을 설정합니다.
- `--disabled-password` : 비밀번호를 설정하지 않습니다. 이 사용자는 비밀번호 없이 로그인 할 수 없습니다.

peter/1234
계정으로 로그인 : su peter
계정종료 : exit

- 다음은 이 프로세스에서 일어나는 주요 단계들입니다:
```bash
sudo adduser username
```

1. **사용자 계정 추가**
    - 이 단계에서는 사용자명을 입력하고, 이 이름의 사용자 계정을 생성합니다.
2. **비밀번호 설정**
    - 시스템은 새로운 사용자의 비밀번호를 두 번 입력하도록 요청합니다. 이 두 입력이 일치하면, 이 비밀번호가 새로운 사용자의 비밀번호로 설정됩니다.
3. **사용자 정보 입력**
    - 이 단계에서는 Full Name, Room Number, Work Phone, Home Phone, Other 등의 사용자 정보를 입력하도록 요청합니다. 이들은 모두 선택 사항이므로, 필요하지 않다면 비워 둘 수 있습니다.
4. **정보 확인**
    - 입력한 정보가 모두 맞는지 확인하도록 요청합니다. 'Y' 또는 'y'를 입력하면, 사용자 계정이 생성되며, 'N' 또는 'n'을 입력하면, 사용자 정보를 다시 입력할 수 있습니다.

이 프로세스를 통해 새 사용자는 생성되며, 새로 생성된 사용자의 홈 디렉토리(`/home/username`)도 함께 생성됩니다. 또한, 새 사용자의 이름으로 그룹도 생성되어 사용자를 그 그룹의 멤버로 추가합니다.


### 사용자 삭제

- `deluser`는 Ubuntu와 같은 Debian 기반 Linux 배포판에서 사용자 계정을 삭제하는 데 사용되는 명령어입니다. `deluser`를 사용하여 시스템에서 사용자 계정을 삭제하고 선택적으로 그와 관련된 홈 디렉토리 및 메일 스풀을 제거할 수 있습니다.

- 다음은 `deluser`의 일반적인 사용 방법에 대한 몇 가지 예입니다.

```bash
sudo deluser username
```

- 위의 명령은 `username`이라는 사용자 계정을 시스템에서 삭제합니다. 여기서 `username`은 실제로 삭제하려는 사용자 계정의 이름으로 바꿔야 합니다.

- 위와 같이 삭제하면 계정만 삭제되고 계정 생성시 생성된 홈디렉토리는 삭제가 안 됩니다.

- 사용자 계정과 홈 디렉토리 삭제
```bash
sudo deluser --remove-home username
#위의 명령은 `username`이라는 사용자 계정을 시스템에서 삭제하고, 해당 사용자의 홈 디렉토리도 함께 삭제합니다.
```


## 그룹관리

- 그룹 관련 정보는 '/etc/group' 파일에 저장됩니다.
- 보통 관리자권한이 있는 상태에서 가능합니다.

- 파일 및 디렉토리의 소유자와 소유 그룹을 변경하려면 `chown` 및 `chgrp` 명령을 사용합니다.

1. `chown`` 명령은 파일 또는 디렉토리의 소유자를 변경합니다. 다음은 사용법의 예입니다.
    
    ```bash
    chown new_owner filename
    ```
    
    이 명령은 'filename'의 소유자를 'new_owner'로 변경합니다.
    
2. `chgrp` 명령은 파일 또는 디렉토리의 그룹 소유자를 변경합니다. 다음은 사용법의 예입니다.
    
    ```bash
    chgrp new_group filename
    ```
    
    이 명령은 'filename'의 그룹 소유자를 'new_group'로 변경합니다.
    

- `chown` 명령을 사용하여 한 번에 소유자와 그룹을 모두 변경할 수 있습니다.

```bash
chown new_owner:new_group filename
# 이 명령은 'filename'의 소유자를 'new_owner'로, 그룹 소유자를 'new_group'으로 변경합니다.

```


## 종료와 재시작

리눅스 환경에서 시스템을 종료하거나 재시작하는 명령어는 간단합니다. 우분투 또는 다른 Linux 배포판에서 사용할 수 있습니다.

### 시스템을 종료하는 방법
- **`sudo shutdown -h now`** : 시스템을 즉시 종료합니다.
- `sudo shutdown -h +m` : m분 후에 시스템을 종료합니다. m은 분을 나타내는 수입니다.
- `sudo halt` 또는 `sudo poweroff` : 이 명령어들도 시스템을 종료합니다.

### 시스템을 재시작하는 방법
- **`sudo shutdown -r now`** : 시스템을 즉시 재시작합니다.
- `sudo shutdown -r +m` : m분 후에 시스템을 재시작합니다. m은 분을 나타내는 수입니다.
- **`sudo reboot`** : 이 명령어도 시스템을 재시작합니다.

- 추가적으로, `shutdown` 명령에는 다양한 옵션들이 있습니다. 예를 들어, `-c` 옵션을 사용하면 예약된 종료나 재시작을 취소할 수 있습니다.
- `shutdown` 명령어 뒤에 문자열을 넣어서 메시지를 전달할 수 있습니다. 

```bash
sudo shutdown -h +5 "System will shutdown after 5 minutes"
# 5분 후에 시스템이 종료된다는 메시지를 다른 사용자들에게 전달할 수 있습니다. 
```


## 사용자 환경 설정

### 환경설정파일

리눅스 시스템에서 환경 설정 파일은 시스템의 동작을 관리하고, 사용자 환경을 정의하는 중요한 역할을 합니다. bash 쉘과 관련된 주요 환경 설정 파일들은 아래와 같습니다:

1. `/etc/profile`: 이 파일은 시스템 전체 사용자에게 적용되는 환경 정보를 저장합니다. 로그인할 때 실행되며, PATH, USER, MAIL, HOSTNAME과 같은 환경 변수를 설정합니다.
2. `~/.bash_profile`: (자주사용)이 파일은 개별 사용자의 환경 설정을 저장하며, 사용자가 로그인할 때마다 실행됩니다. 이 파일은 일반적으로 사용자의 HOME, PATH, PS1 등의 환경 변수를 설정합니다.
    로그인시 실행할... 명령어들을 미리 작성해놓을 수 있음.(로그인과 동시에 실행할것들)
3. `~/.bashrc`: (자주사용)이 파일은 쉘 스크립트를 시작할 때마다 실행되는 사용자의 환경 설정을 저장합니다. 즉, 새 터미널 창을 열거나, 새 쉘 세션을 시작할 때마다 실행됩니다. 주로 사용자의 alias, 함수, 쉘 프롬프트 등을 설정합니다.
    alias같은거 선언되어있습니다. 재연결하면 alias가 업서이지 때문에 설정해놓는 파일
4. `/etc/bashrc`: 이 파일은 모든 사용자가 bash 쉘을 시작할 때마다 실행되며, 일반적으로 시스템 관리자가 시스템 전체의 bash 쉘 동작을 설정하기 위해 사용합니다.
5. `~/.bash_logout`: 사용자가 로그아웃할 때 실행되는 스크립트입니다. 일반적으로 일부 정리 작업, 예를 들어 임시 파일 삭제 등을 처리하는 데 사용됩니다.
6. `/etc/environment`: 이 파일은 시스템 전체의 환경 정보를 저장하는 데 사용되며, 주로 시스템의 PATH 환경 변수를 설정하는 데 사용됩니다.

### 호출순서

리눅스 시스템에서 환경 설정 파일들이 호출되는 순서는 다음과 같습니다:

1. 사용자 로그인:
    1. `/etc/profile` (시스템 전체 환경 설정)
    2. `~/.bash_profile` (사용자 환경 설정)
    
    이 두 파일이 호출되고, 일반적으로 `~/.bash_profile` 내부에서 `~/.bashrc` 파일을 호출하게 설정되어 있습니다.
    
2. 새 쉘 세션 시작 (터미널 창 열기 등):
    1. `~/.bashrc` (사용자 쉘 세션 환경 설정)
    2. `/etc/bashrc` (시스템 전체 쉘 세션 환경 설정)
3. 사용자 로그아웃:
    
    `~/.bash_logout` (로그아웃 시 수행되는 작업)
    

따라서 호출 순서는 대략적으로 다음과 같습니다:

```
로그인 ──> /etc/profile ──> ~/.bash_profile ──> ~/.bashrc ──> /etc/bashrc
  │
  └──> 로그아웃 ──> ~/.bash_logout
```

위의 순서는 일반적인 경우의 예입니다. 
실제로는 각각의 설정 파일 안에서 다른 설정 파일을 호출하는 방식으로 조정할 수 있기 때문에, 상황에 따라서 조금씩 다를 수 있습니다.

### 환경변수

1. 프로그램 또는 스크립트가 실행되는 환경을 설정합니다. 예를 들어, `PATH` 환경 변수는 셸이 명령어를 찾을 수 있는 디렉토리를 지정합니다.

2. 프로세스 간에 데이터를 전달합니다. 예를 들어, `HOME` 환경 변수는 사용자의 홈 디렉토리 경로를 저장합니다.

예를 들어:

- 환경 변수 만들기: `export VARNAME="value"`
- 환경 변수 확인: `echo $VARNAME`
- 환경 변수 제거: `unset VARNAME`

환경 변수는 Linux 운영 체제의 매우 중요한 부분이며, 시스템 설정, 프로그램 구성, 네트워크 설정 등 많은 작업에 사용됩니다.

- 환경변수를 미리 저장해두는 곳
  - .bash_profile
  - .bashrc
  - 이런곳에 가서 export 를해놓으면 실행할때마다 설정되어있게 할 수 있습니다.


## 애플리케이션 설치 및 삭제

Ubuntu Linux에서는 주로 "apt" 패키지 관리 도구를 사용하여 애플리케이션을 설치하고 삭제합니다.

### 애플리케이션 설치하기

1. `apt update`: 패키지 목록을 최신 상태로 업데이트합니다. 이 명령은 패키지 설치나 업그레이드 전에 실행하는 것이 일반적입니다.
    
    ```bash
    sudo apt update
    ```
    
2. `apt install [package-name]`: 특정 패키지를 설치합니다. "[package-name]" 부분은 설치하려는 패키지의 이름으로 대체해야 합니다.
    
    ```bash
    sudo apt install [package-name]
    
    # nginx설치
    sudo apt install nginx
    ```
    

설치하고 싶은 프로그램 있으면 구글에
howto install [프로그램이름] on ubuntu 22.04 하면 됨


### 애플리케이션 삭제하기

```bash
sudo apt remove nginx
```

기존에 존재하는 환경파일까지 모두 삭제하고싶으면
```bash
sudo apt purge nginx
```


# 교안

- https://paullabworkspace.notion.site/AWS-2c7f7b69557247acbb0d862547fb71cc